TABLE OF CONTENTS

prometheus.library/Prm_AddIntServer
prometheus.library/Prm_RemIntServer
prometheus.library/Prm_AllocDMABuffer
prometheus.library/Prm_FindBoardTagList
prometheus.library/Prm_FreeDMABuffer
prometheus.library/Prm_GetBoardAttrsTagList
prometheus.library/Prm_ReadConfigByte
prometheus.library/Prm_ReadConfigLong
prometheus.library/Prm_ReadConfigWord
prometheus.library/Prm_SetBoardAttrsTagList
prometheus.library/Prm_WriteConfigByte
prometheus.library/Prm_WriteConfigLong
prometheus.library/Prm_WriteConfigWord
prometheus.library/Prm_GetPhysicalAddress
prometheus.library/Prm_GetVirtualAddress

   NAME
       Prm_AddIntServer -- Adds PCI interrupt service routine to the
                           system. (V2)

   SYNOPSIS
       Success = Prm_AddIntServer (Board, Interrupt)
                                   A0     A1

       BOOL Prm_AddIntServer (PCIBoard*, struct Interrupt*);

   FUNCTION
       Adds an interrupt server to a system interrupt server chain
       responsible for interrupts generated by PCI boards in Prometheus.
       With current hardware all these interrupt servers will be added
       to INTB_PORTS chain, but this will change with G4 board.

   INPUTS
       Board    -  "Blackbox" structure pointer returned by
                   Prm_FindBoardTagList(). It can be NULL, function returns
                   immediately in the case with FALSE value. Don't pass
                   random values here.
       Interrupt-  Properly initialized Interrupt structure, exactly like
                   for exec AddIntServer() call. Interrupt code have to take
                   into account that PCI interrupts are shared, that means
                   every interrupt server should check if interrupt was
                   generated by 'its' board or another one. If int server
                   claims the interrupt it returns 1, zero otherwise.

   RESULT
       TRUE if interrupt was successfully installed, FALSE otherwise.

   NOTES
       Current exec.library requires that interrupt server claiming an
       interrupt exits with zero CPU flag cleared. Server should set
       the flag if this interrupt was not handled by it. You have to ensure
       CPU flags are set properly at server routine exit. It can be done
       using __interrupt attribute for server routine, which cause setting
       processor flags according to return value:

       __interrupt IntCode(userdata reg(a1))
         {
           if (check_int())
             {
               /* handle the interrupt */
               return (1);
             }
           else return (0);
         }

      If your compiler does not support __interrupt attribute you have to
      use assembler stub:

      _IntStub:  LEA     _IntCode,a0
                 JSR     (a0)
                 TST.L   d0        ;sets CPU flags according to return value
                 RTS

       and put IntStub() into is_Code field of struct Interrupt.

   BUGS

   SEE ALSO
       Prm_RemIntServer(), exec.library/AddIntServer()

prometheus.library/Prm_RemIntServer       prometheus.library/Prm_RemIntServer

   NAME
       Prm_RemIntServer -- Removes PCI interrupt service routine from the
                           system. (V2)

   SYNOPSIS
       Prm_RemIntServer (Board, Interrupt)
                         A0     A1

       VOID Prm_RemIntServer (PCIBoard*, struct Interrupt*);

   FUNCTION
       Removes a PCI interrupt service routine previously added by
       Prm_AddIntServer() call.

   INPUTS
       Board    -  "Blackbox" structure pointer returned by
                   Prm_FindBoardTagList(). It can be NULL, function returns
                   immediately in the case. Don't pass random values here.
       Interrupt - Interrupt structure given as a parameter for
                   Prm_AddIntServer().

   RESULT
       None.

   NOTES

   BUGS

   SEE ALSO
       Prm_AddIntServer()

prometheus.library/Prm_AllocDMABuffer   prometheus.library/Prm_AllocDMABuffer

   NAME
       Prm_AllocDMABuffer -- Allocates memory buffer DMA-able on PCI bus.
                             (V2)

   SYNOPSIS
       Buffer = Prm_AllocDMABuffer (Size)
                                    D0

       APTR Prm_AllocDMABuffer (ULONG);

   FUNCTION
       Allocates a memory buffer accessible for PCI boards using DMA in
       busmaster mode to fetch and store data.

   INPUTS
       Size    -  Size of requested memory block in bytes. It will be
                  rounded up to nearest longword boundary. Returned block
                  is always longword aligned. Zero size is an no-op with
                  NULL pointer returned.
   RESULT
       Buffer  -  Address of memory block allocated or NULL if there is no
                  more free DMA-able memory. Note well - this is logical
                  address as seen by CPU. To obtain physical PCI bus address
                  (used e.g. when programming board's DMA controllers) use
                  Prm_GetPhysicalAddress() function.

   NOTES
       Function must not be called from an interrupt.

   BUGS

   SEE ALSO
       Prm_FreeDMABuffer(), Prm_GetPhysicalAddress()

prometheus.library/Prm_FindBoardTagListrometheus.library/Prm_FindBoardTagList

   NAME
       Prm_FindBoardTagList -- Finds PCI board with attributes given in the
               taglist.
       Prm_FindBoardTags -- Varargs stub for Prm_FindBoardTagList.

   SYNOPSIS
       Board = Prm_FindBoardTagList (Previous, TagList)
                                     A0        A1

       PCIBoard *Prm_FindBoardTagList (PCIBoard*, struct TagItem*);

       Board = Prm_FindBoardTags (Previous, Tag1, ...)

       PCIBoard *Prm_FindBoardTags (PCIBoard*, Tag, ...);

   FUNCTION
       Finds all PCI boards connected to any Prometheus PCI bridge in the
       system, matching the tags in the TagList. First call returns first
       matching board found. To find all the matching boards call the
       function in loop until it returns NULL.

   INPUTS
       Previous  - pointer to a "blackbox" PCI board structure. The function
                   will search board list from the *next* board after
                   Previous. NULL value means "start search from the
                   beginning of internal list".
       TagList   - list of tags all boards will be checked against.
                   Empty taglist (TagList points to LONG 0), or NULL
                   here means all the boards will be returned in turn.

   RESULT
       Board     - a pointer to a "blackbox" PCI board structure. Don't try
                   to peeking and pokeing it, use only as a parameter in
                   prometheus.library calls. Function can return NULL if no
                   [more] matching boards can be found.

   EXAMPLE
       Let's check if any Voodoo3 2000 board is plugged in:

       PCIBoard *board = NULL;

       while (board = Prm_FindBoardTags (board, PRM_Vendor,
        0x121A, PRM_Device, 5, TAG_END))
        {
         /* do something with 'board' */
        }

   NOTES
       Don't give random values as Previous board. It should be only pointer
       returned by Prm_FindBoardTagList() call or NULL.

   BUGS

   SEE ALSO
       Prm_GetBoardAttrsTagList()

prometheus.library/Prm_FreeDMABuffer     prometheus.library/Prm_FreeDMABuffer

   NAME
       Prm_FreeDMABuffer -- Frees DMA-able memory buffer. (V2)

   SYNOPSIS
       Prm_FreeDMABuffer (Buffer, Size)
                          A0      D0

       VOID Prm_FreeDMABuffer (APTR, ULONG);

   FUNCTION
       Frees a memory buffer allocated by Prm_AllocDMABuffer() call.

   INPUTS
       Buffer  -  Address of allocated memory block as returned by
                  Prm_AllocDMABuffer(). NULL address is a no-op.
       Size    -  Size of allocated block. Must match size given for
                  Prm_AllocDMABuffer(). Zero size is a no-op.
   RESULT
       None.

   NOTES
       Function must not be called from an interrupt.

   BUGS

   SEE ALSO
       Prm_AllocDMABuffer(), Prm_GetPhysicalAddress()

prometheus.library/Prm_GetBoardAttrsTagLists.library/Prm_GetBoardAttrsTagList

   NAME
       Prm_GetBoardAttrsTagList -- reads information about PCI board.
       Prm_GetBoardAttrsTags -- Varargs stub for Prm_GetBoardAttrsTagList.

   SYNOPSIS
       TagsRead = Prm_GetBoardAttrsTagList (Board, TagList)
                                 A0     A1

       ULONG Prm_GetBoardAttrsTagList (PCIBoard*, struct TagItem*);

       TagsRead = Prm_GetBoardAttrsTags (Board, Tag1, ...)

       ULONG Prm_GetBoardAttrsTags (PCIBoard*, Tag, ...);

   FUNCTION
       Reads information from board internal structure and writes it
       according to given taglist. Function looks for every passed tag value
       in database and if found writes its value at address given in ti_Data
       in passed TagList.

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList(). It can be NULL, function returns
                 immediately in the case, no data is written. Don't pass
                 random values here.
       TagList - Function will search in internal database for every ti_Tag
                 in the TagList. If tag is found, ti_Data field is used as a
                 pointer to ULONG and the information is written at the
                 address. Unrecognized tags are skipped and 0 is written to
                 the given ti_Data location. TagList can be NULL,
                 function returns immediately at the case, no data are
                 written. If ti_Data field of any tag is NULL, no data is
                 written for this tag. Following tags are recognized:

       PRM_Vendor      - Board vendor number assigned by PCISIG.
       PRM_Device      - Device number assigned by manufacturer.
       PRM_Revision    - Device revision number assigned by manufacturer.
       PRM_Class       - Device class as defined in PCI specification.
       PRM_SubClass    - Device subclass as defined in PCI specification.
       PRM_MemoryAddrX - (where X can be from '0' to '5'), PCI board can
           have up to six memory blocks allocated. These tags contains base
           adresses of blocks assigned by prometheus.library in init code.
           NULL value means a block is not used.  You can depend on fact
           that the last nybble of PRM_MemoryAddrX is equal to X. It is
           guarranted in future releases. So the code below is valid:

       /* read all possible base adresses */

       ULONG baseaddr;

       for (i = 0; i < 6; i++)
        {
         Prm_GetBoardAttrsTags (any_board, PRM_MemoryAddr0 + i,
          (ULONG)&baseaddr, TAG_END);
        }

       PRM_MemorySizeX - (where X can be from '0' to '5'), PCI board can
           have up to six memory blocks allocated. These tags contains sizes
           of blocks assigned by prometheus.library in init code. NULL value
           means a block is not used.  You can depend on fact that the last
           nybble of PRM_MemorySizeX is equal to X. It is guarranted in
           future releases (see code above).
       PRM_ROM_Address - Address of PCI on-board ROM (if found).
       PRM_ROM_Size - Size of PCI on-board ROM (if found).
       PRM_BoardOwner (V2) - an address of driver which claimed the board.
           Typically it points to struct Node, and driver name can be read
           from ln_Name field.
       PRM_SlotNumber (V2) - number of the physical PCI slot the board is
           inserted in. Range from 0 to 3 for primary PCI bus.
       PRM_FunctionNumber (V2) - number of device function. For single-
           -function devices always 0, for multifunction from 0 to 7. Every
           function of a multifunction board is reported by prometheus.librar
y
           as a separate "board".

   RESULT
       TagsRead - Number of succesfully read tags.

   EXAMPLE
       Get first base address and block size of the card:

       APTR baseaddress = NULL;
       ULONG blocksize = 0;

       Prm_GetBoardAttrsTags (any_board,
         PRM_MemoryAddr0, (ULONG)&baseaddress,
         PRM_MemorySize0, (ULONG)&blocksize,
         TAG_END);

   NOTES

   BUGS

   SEE ALSO
       Prm_SetBoardAttrsTagList()

prometheus.library/Prm_ReadConfigByte   prometheus.library/Prm_ReadConfigByte

   NAME
       Prm_ReadConfigByte -- reads a byte (8 bits) from config space of
                             given PCI board. (V2)

   SYNOPSIS
       Value = Prm_ReadConfigByte (Board, Offset)
                                   A0     D0:8

       UBYTE Prm_ReadConfigByte (PCIBoard*, UBYTE);

   FUNCTION
       This function allows for direct reading of PCI board config space.
       Takes care of data endianness. Data are always returned as big
       endian. For example if VendorID is $5678 and DeviceID is $1234 then:
       Prm_ReadConfigByte(board, 0) returns $12,
       Prm_ReadConfigByte(board, 1) returns $34,
       Prm_ReadConfigByte(board, 2) returns $56,
       Prm_ReadConfigByte(board, 3) returns $78,

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Offset  - Config space offset in bytes to read from.

   RESULT
       Value   - Value read from PCI board.

   NOTES

   BUGS

   SEE ALSO
       Prm_ReadConfigLong(), Prm_ReadConfigWord(), Prm_WriteConfigByte()

prometheus.library/Prm_ReadConfigLong   prometheus.library/Prm_ReadConfigLong

   NAME
       Prm_ReadConfigLong -- reads a longword (32 bits) from config
                             space of given PCI board. (V2)

   SYNOPSIS
       Value = Prm_ReadConfigLong (Board, Offset)
                                   A0     D0:8

       ULONG Prm_ReadConfigLong (PCIBoard*, UBYTE);

   FUNCTION
       This function allows for direct reading of PCI board config space.
       Takes care of data endianness, data are always returned as big
       endian.

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Offset  - Config space offset in bytes to read from.

   RESULT
       Value   - Longword read from PCI board.

   NOTES

   BUGS

   SEE ALSO
       Prm_ReadConfigWord(), Prm_ReadConfigByte(), Prm_WriteConfigLong()

prometheus.library/Prm_ReadConfigWord   prometheus.library/Prm_ReadConfigWord

   NAME
       Prm_ReadConfigWord -- reads a word (16 bits) from config space of
                             given PCI board. (V2)

   SYNOPSIS
       Value = Prm_ReadConfigWord (Board, Offset)
                                   A0     D0:8

       UWORD Prm_ReadConfigWord (PCIBoard*, UBYTE);

   FUNCTION
       This function allows for direct reading of PCI board config space.
       Takes care of data endianness, data are always returned as big
       endian. For example if VendorID is $5678 and DeviceID is $1234 then:
       Prm_ReadConfigWord(board, 0) returns $1234,
       Prm_ReadConfigWord(board, 2) returns $5678,

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Offset  - Config space offset in bytes to read from.

   RESULT
       Value   - Word read from PCI board.

   NOTES

   BUGS

   SEE ALSO
       Prm_ReadConfigLong(), Prm_ReadConfigByte(), Prm_WriteConfigWord()

prometheus.library/Prm_SetBoardAttrsTagLists.library/Prm_SetBoardAttrsTagList

   NAME
       Prm_SetBoardAttrsTagList -- Sets a PCI board attributes. (V2)
       Prm_SetBoardAttrsTags -- Varargs stub for Prm_SetBoardAttrsTagList.

   SYNOPSIS
       Attrs = Prm_SetBoardAttrsTagList (Board, TagList)
                                         A0     A1

       ULONG Prm_SetBoardAttrsTagList (PCIBoard*, struct TagItem*);

       Attrs = Prm_SetBoardAttrsTags (Board, Tag1, ...)

       ULONG Prm_SetBoardAttrsTags (PCIBoard*, Tag, ...);

   FUNCTION
       Sets an attribute of a PCI board. Note that not all attributes are
       settable (this is defined in 'libraries/prometheus.h' include file).
       Function looks for every passed tag value in TagList and if found in
       the data base and writing the attribute is permitted new value is
       recorded in the database.

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList(). It can be NULL, function returns
                 immediately in the case, no data is written, function
                 returns 0. Don't pass random values here.
       TagList - Function will search in internal database for every ti_Tag
                 in the TagList. If tag is found, ti_Data field is used as a
                 new value in the database if setting the attibute is
                 permitted. Unrecognized tags are skipped. TagList can be
                 NULL, function returns immediately at the case, no data are
                 changed, function returns FALSE. Following tags are
                 recognized and allowed for setting:

           PRM_BoardOwner - Contains an address of driver which claimed the
                 board. Only device drivers should set it. If this attribute
                 was NULL before setting, it will be set succesfully and the
                 function returns TRUE. If the attribute was set already to
                 non NULL value by someone else and the new value is non
                 NULL (setting the attribute to NULL means "unlocking"
                 hardware) the function fails, it means old value stays
                 unchanged and the function returns FALSE. This way a driver
                 can "lock" its hardware. You can always set this attribute
                 to an address of your Library or Device structure. If your
                 driver is neither library nor device (which is strongly
                 discouraged) set the attribute to a Node structure with
                 valid ln_Name field.

   EXAMPLE
       Try to acquire hardware inside the driver:

       if (Prm_SetBoardAttrsTags(board,
         PRM_BoardOwner, (LONG)MyDeviceBase,
         TAG_END))
         {
           /* proceed with the hardware */
         }
       else
         {
           /* somebody already claimed the hadrware */
           /* inform the user and quit              */
         }

   RESULT
       Number of attributes succesfully set. In current (V2) library it can
       be 0 or 1 (for PRM_BoardOwner).

   NOTES

   BUGS

   SEE ALSO
       Prm_GetBoardAttrsTagList()

prometheus.library/Prm_WriteConfigByte prometheus.library/Prm_WriteConfigByte

   NAME
       Prm_WriteConfigByte -- writes a byte (8 bits) to config space of
                              given PCI board. (V2)

   SYNOPSIS
       Prm_WriteConfigByte (Board, Data, Offset)
                            A0     D0:8  D1:8

       VOID Prm_WriteConfigWord (PCIBoard*, UBYTE, UBYTE);

   FUNCTION
       This function allows for direct writing to PCI board config space.
       Takes care of data endianness, you should specify data in big-endian
       mode. Words will be writen as follows:

       offset 0     offset 1     offset 2     offset 3

       bits 7-0     bits 7-0     bits 7-0     bits 7-0

                  configuration longword

       bits 31-24   bits 23-16   bits 15-8    bits 7-0

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Data    - Data to be written to PCI board.
       Offset  - Config space offset in bytes to write to.

   RESULT
       None.

   NOTES
       Offsets from 0 to $40 are configured at boot time and must not be
       changed by any application.

   BUGS

   SEE ALSO
       Prm_WriteConfigWord(), Prm_WriteConfigLong(), Prm_ReadConfigByte()

prometheus.library/Prm_WriteConfigLong prometheus.library/Prm_WriteConfigLong

   NAME
       Prm_WriteConfigLong -- writes a longword (32 bits) to config space of
                              given PCI board. (V2)

   SYNOPSIS
       Prm_WriteConfigLong (Board, Data, Offset)
                            A0     D0    D1:8

       VOID Prm_WriteConfigLong (PCIBoard*, ULONG, UBYTE);

   FUNCTION
       This function allows for direct writing to PCI board config space.
       Takes care of data endianness, you should specify data in big-endian
       mode.

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Data    - Data to be written to PCI board.
       Offset  - Config space offset in bytes to write to.

   RESULT
       None.

   NOTES
       Offsets from 0 to $40 are configured at boot time and must not be
       changed by any application.

   BUGS

   SEE ALSO
       Prm_WriteConfigWord(), Prm_WriteConfigByte(), Prm_ReadConfigLong()

prometheus.library/Prm_WriteConfigWord prometheus.library/Prm_WriteConfigWord

   NAME
       Prm_WriteConfigWord -- writes a word (16 bits) to config space of
                              given PCI board. (V2)

   SYNOPSIS
       Prm_WriteConfigWord (Board, Data, Offset)
                            A0     D0:16 D1:8

       VOID Prm_WriteConfigWord (PCIBoard*, UWORD, UBYTE);

   FUNCTION
       This function allows for direct writing to PCI board config space.
       Takes care of data endianness, you should specify data in big-endian
       mode. Words will be writen as follows:

              offset 0                 offset 2

       bits 15-8    bits 7-0     bits 15-8    bits 7-0

                  configuration longword

       bits 31-24   bits 23-16   bits 15-8    bits 7-0

   INPUTS
       Board   - "Blackbox" structure pointer returned by
                 Prm_FindBoardTagList().
       Data    - Data to be written to PCI board.
       Offset  - Config space offset in bytes to write to.

   RESULT
       None.

   NOTES
       Offsets from 0 to $40 are configured at boot time and must not be
       changed by any application.

   BUGS

   SEE ALSO
       Prm_WriteConfigLong(), Prm_WriteConfigByte(), Prm_ReadConfigWord()

prometheus.library/Prm_GetPhysicalAddress    prometheus.library/Prm_GetPhysicalAddress

   NAME
       Prm_GetPhysicalAddress -- Converts logical address in Prometheus
         address space to physical address on PCI bus. (V2)

   SYNOPSIS
       PhyAddr = Prm_GetPhysicalAddress (Address)
                                         D0

       APTR Prm_GetPhysicalAddress (APTR);

   FUNCTION
       Calculates physical PCI bus address of any address in Prometheus
       address space. This physical address is especially useful for
       programming DMA buffer address in PCI boards' DMA controllers.

   INPUTS
       Address -  Logical address as seen by CPU. Address is checked if it
                  belongs to Prometheus PCI Memory space.
   RESULT
       PhyAddr -  The same address as seen by PCI boards. If given parameter
                  is not a valid logical PCI address in Memory space
                  function returns NULL.

   NOTES

   BUGS

   SEE ALSO
       Prm_AllocDMABuffer()

prometheus.library/Prm_GetVirtualAddress    prometheus.library/Prm_GetVirtualAddress

   NAME
       Prm_GetVirtualAddress -- Converts physical address on PCI bus to
       logical/virtual address in Prometheus address space. (V3)

   SYNOPSIS
       VirtAddr = Prm_GetVirtualAddress (Address)
                                         D0

       APTR Prm_GetVirtualAddress (APTR);

   FUNCTION
       Converts physical address on PCI bus to logical/virtual address 
       in Prometheus address space.
       This logical/virtual address is especially useful to read/write in 
       DMA memory with the CPU.

   INPUTS
       Address -  The same address as seen by PCI boards. If given parameter
                  is not a valid logical PCI address in Memory space
                  function returns NULL.
   RESULT
       VirtAddr - Logical/Virtual address as seen by CPU. Address is checked if it
                  belongs to Prometheus PCI Memory space.

   NOTES

   BUGS

   SEE ALSO
       Prm_AllocDMABuffer()
